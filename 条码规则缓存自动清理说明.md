# 条码规则缓存自动清理功能说明

## 功能概述

在前端条码规则管理界面进行任何规则调整时，系统会**自动清理相关的 Redis 缓存**，确保数据实时性。

## 实现内容

### 1. 后端接口（`dcMes_server/routes/barcodeRule.js`）

#### 接口 1：清除条码规则缓存

```javascript
GET /clearBarcodeRuleCache
```

**Query 参数**：
- `materialId`: string | string[] - 物料ID（可选）
  - 不传：清除所有缓存
  - 单个ID：清除指定物料的缓存
  - 多个ID（逗号分隔）：批量清除多个物料的缓存

**返回示例**：
```json
{
  "success": true,
  "message": "已清除 3 个物料的条码规则缓存",
  "type": "batch",
  "count": 3,
  "timestamp": "2025-10-31T10:30:00.000Z"
}
```

#### 接口 2：获取缓存统计信息

```javascript
GET /api/barcode-rule-cache/stats
```

**返回示例**：
```json
{
  "success": true,
  "data": {
    "connected": true,
    "total": 25,
    "active": 20,
    "expired": 5,
    "cacheTimeout": "300秒",
    "db": 3,
    "keyPrefix": "barcode_rule:"
  },
  "timestamp": "2025-10-31T10:30:00.000Z"
}
```

### 2. 前端集成（`dcMes_vue_system/src/views/barcodeRule/index.vue`）

#### 自动缓存清理场景

系统在以下操作后会**自动清除相关缓存**：

| 操作 | 清理范围 | 说明 |
|------|---------|------|
| **创建规则** | 全局规则：所有缓存<br>普通规则：无需清理 | 新创建的普通规则还没有物料绑定 |
| **更新规则** | 全局规则：所有缓存<br>普通规则：关联物料 | 更新规则后需要清除使用该规则的物料缓存 |
| **删除规则** | 全局规则：所有缓存<br>普通规则：关联物料 | 删除规则后需要清除使用该规则的物料缓存 |
| **批量删除规则** | 包含全局规则：所有缓存<br>仅普通规则：所有关联物料 | 批量删除时智能判断清理范围 |
| **绑定物料** | 该物料 | 为物料绑定规则后，清除该物料的缓存 |
| **解绑物料** | 该物料 | 解除物料绑定后，清除该物料的缓存 |

#### 核心方法

##### 1. `clearCache(materialIds)`
```javascript
/**
 * 清理条码规则缓存
 * @param {string|Array<string>} materialIds - 物料ID（可选）
 */
async clearCache(materialIds = null) {
  // 自动转换参数格式并调用后端接口
  // 失败不影响主流程，只记录日志
}
```

##### 2. `getMaterialIdsByRule(ruleId)`
```javascript
/**
 * 获取规则关联的所有物料ID
 * @param {string} ruleId - 规则ID
 * @returns {Promise<Array<string>>} 物料ID数组
 */
async getMaterialIdsByRule(ruleId) {
  // 查询 productBarcodeRule 表获取关联物料
}
```

## 使用示例

### 场景 1：创建全局规则

```javascript
// 用户在前端创建了一个全局规则
// 系统自动执行：
await addData('barcodeRule', { 
  name: '全局规则A', 
  isGlobal: true,
  // ...其他字段
});

// 自动清除所有缓存
await this.clearCache();
```

**日志输出**：
```
✅ 缓存清理成功: 已清除所有条码规则缓存
```

### 场景 2：更新普通规则

```javascript
// 用户更新了一个普通规则
// 系统自动执行：

// 1. 获取该规则关联的所有物料
const materialIds = await this.getMaterialIdsByRule(ruleId);
// 结果：['material001', 'material002', 'material003']

// 2. 更新规则
await updateData('barcodeRule', { query: { _id: ruleId }, update: data });

// 3. 清除相关物料的缓存
await this.clearCache(materialIds);
```

**日志输出**：
```
✅ 缓存清理成功: 已清除 3 个物料的条码规则缓存
```

### 场景 3：绑定物料到规则

```javascript
// 用户为"规则A"绑定了"物料B"
// 系统自动执行：

await addData('productBarcodeRule', {
  productId: 'material_b_id',
  barcodeRule: 'rule_a_id'
});

// 自动清除该物料的缓存
await this.clearCache('material_b_id');
```

**日志输出**：
```
✅ 缓存清理成功: 已清除物料 material_b_id 的条码规则缓存
```

### 场景 4：批量删除规则

```javascript
// 用户选择了3个规则进行批量删除（包含1个全局规则）
// 系统自动执行：

// 1. 检查是否包含全局规则
const hasGlobalRule = true;

// 2. 删除规则
await removeData('barcodeRule', { query: { _id: { $in: ruleIds } } });

// 3. 因为包含全局规则，清除所有缓存
await this.clearCache();
```

**日志输出**：
```
✅ 缓存清理成功: 已清除所有条码规则缓存
```

## 缓存清理逻辑

### 智能清理策略

```
┌─────────────────────────────────────────┐
│         用户在前端进行操作              │
└────────────────┬────────────────────────┘
                 │
                 ▼
┌─────────────────────────────────────────┐
│    执行数据库操作（创建/更新/删除）     │
└────────────────┬────────────────────────┘
                 │
                 ▼
         ┌───────┴───────┐
         │   判断操作类型   │
         └───────┬───────┘
                 │
        ┌────────┼────────┐
        │                 │
        ▼                 ▼
┌─────────────┐   ┌─────────────┐
│  全局规则？  │   │  普通规则？  │
└──────┬──────┘   └──────┬──────┘
       │                 │
       ▼                 ▼
┌──────────────┐  ┌──────────────┐
│ 清除所有缓存 │  │获取关联物料ID│
└──────┬───────┘  └──────┬───────┘
       │                 │
       │                 ▼
       │          ┌──────────────┐
       │          │清除物料缓存  │
       │          └──────┬───────┘
       │                 │
       └────────┬────────┘
                │
                ▼
┌─────────────────────────────────────────┐
│      Redis 缓存已更新，数据实时生效     │
└─────────────────────────────────────────┘
```

### 缓存清理范围决策表

| 规则类型 | 操作 | 清理范围 | 判断依据 |
|---------|------|---------|---------|
| 全局规则 | 创建 | 所有缓存 | `isGlobal === true` |
| 全局规则 | 更新 | 所有缓存 | `isGlobal === true` |
| 全局规则 | 删除 | 所有缓存 | `isGlobal === true` |
| 普通规则 | 创建 | 无需清理 | 还没有物料绑定 |
| 普通规则 | 更新 | 关联物料 | 查询 `productBarcodeRule` |
| 普通规则 | 删除 | 关联物料 | 查询 `productBarcodeRule` |
| 批量删除 | - | 取决于是否包含全局规则 | 检查 `selection` 数组 |
| 物料绑定 | 新增 | 该物料 | `productId` |
| 物料绑定 | 删除 | 该物料 | `productId` |

## 错误处理

### 缓存清理失败处理

```javascript
async clearCache(materialIds = null) {
  try {
    // 调用清理接口
    const result = await clearBarcodeRuleCache(params);
    
    if (result.success) {
      console.log('✅ 缓存清理成功:', result.message);
    } else {
      console.warn('⚠️ 缓存清理失败:', result.error);
    }
  } catch (error) {
    console.error('❌ 清理缓存异常:', error);
    // 缓存清理失败不影响主流程，只记录日志
  }
}
```

**设计原则**：
1. **缓存清理失败不影响主业务流程**
2. **所有错误都会记录在控制台**
3. **用户仍然能看到操作成功的提示**

### 可能的错误场景

| 错误场景 | 错误日志 | 用户影响 | 解决方案 |
|---------|---------|---------|---------|
| Redis 连接失败 | ❌ 清理缓存异常: connect ECONNREFUSED | 无影响 | 检查 Redis 服务 |
| 网络超时 | ❌ 清理缓存异常: timeout | 无影响 | 检查网络连接 |
| 后端接口错误 | ⚠️ 缓存清理失败: Internal Server Error | 无影响 | 查看后端日志 |

## 监控与验证

### 验证缓存是否清理成功

#### 方法 1：查看浏览器控制台

在浏览器开发者工具的 Console 中查看日志：

```
✅ 缓存清理成功: 已清除物料 64a1b2c3d4e5f6789012345 的条码规则缓存
```

#### 方法 2：使用 Redis CLI

```bash
# 连接 Redis
redis-cli -h localhost -p 6379

# 切换到 DB 3
SELECT 3

# 查看所有缓存键
KEYS barcode_rule:*

# 查看特定物料的缓存
GET barcode_rule:64a1b2c3d4e5f6789012345

# 如果返回 (nil) 说明缓存已被清除
```

#### 方法 3：调用统计接口

```javascript
// 在浏览器控制台执行
fetch('/api/barcode-rule-cache/stats')
  .then(res => res.json())
  .then(data => console.log('缓存统计:', data));
```

## 性能影响

### 缓存清理性能

| 操作 | 清理范围 | 耗时 | 影响 |
|------|---------|------|------|
| 清除单个物料 | 1个键 | ~2-5ms | 可忽略 |
| 清除多个物料 | N个键 | ~5-20ms | 可忽略 |
| 清除所有缓存 | 全部键 | ~10-50ms | 可忽略 |

### 对用户体验的影响

- ✅ **操作不受阻塞**：缓存清理异步执行，不影响界面响应
- ✅ **数据实时更新**：清理后下次查询立即使用最新规则
- ✅ **失败不影响主流程**：清理失败只记录日志，不中断用户操作

## 最佳实践

### 开发者注意事项

1. **添加新的规则操作时**：
   - 确认是否需要清理缓存
   - 判断清理范围（全局/特定物料）
   - 在操作成功后调用 `clearCache()`

2. **调试时**：
   - 在浏览器控制台查看缓存清理日志
   - 使用 Redis CLI 验证缓存状态
   - 测试缓存清理失败的情况

3. **性能考虑**：
   - 批量操作时收集所有ID后一次性清理
   - 避免在循环中逐个清理缓存
   - 全局规则操作后直接清空所有缓存

### 运维注意事项

1. **Redis 监控**：
   - 监控 Redis 连接状态
   - 定期检查缓存键数量
   - 设置缓存过期告警

2. **日志分析**：
   - 定期查看缓存清理失败日志
   - 分析清理失败的原因
   - 优化清理策略

## 相关文档

- [Redis 缓存配置说明](./Redis缓存配置说明.md)
- [Redis 缓存管理指南](./Redis缓存管理指南.md)
- [从内存缓存升级到 Redis 缓存](./从内存缓存升级到Redis缓存.md)
- [Redis 缓存快速参考](./Redis缓存快速参考.md)

## 总结

### 实现效果

- ✅ **自动化**：所有规则调整后自动清理缓存
- ✅ **智能化**：根据规则类型智能决定清理范围
- ✅ **健壮性**：清理失败不影响主业务流程
- ✅ **实时性**：清理后数据立即生效
- ✅ **易维护**：统一的清理逻辑，代码简洁

### 技术亮点

1. **智能清理策略**：自动判断是否需要清理以及清理范围
2. **异常容错**：清理失败不影响主流程
3. **性能优化**：批量操作时一次性清理
4. **日志完整**：详细的日志记录便于调试和监控

---

如有任何问题，请参考上述文档或联系技术支持。

