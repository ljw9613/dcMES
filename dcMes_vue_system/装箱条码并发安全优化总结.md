# 装箱条码并发安全机制优化总结

## 优化概述

本次优化主要解决了装箱条码管理中的以下问题：
1. 物料切换时装箱条码锁定未正确清理
2. 页面刷新时清理逻辑未被调用
3. 设备标识不够稳定和唯一，影响多产线并发
4. 锁定状态管理不够完善

## 主要优化内容

### 1. 物料切换时的智能锁定清理

#### 新增功能：
- **监听物料变化**：通过 `watch` 监听 `mainMaterialId` 变化
- **智能清理机制**：当检测到物料或产线变化时，自动清理不匹配的锁定
- **状态验证**：对比当前物料与已锁定条码的物料信息

#### 关键方法：
```javascript
// 监听物料变化并清理锁定
async mainMaterialId(newVal, oldVal) {
  if (oldVal && newVal !== oldVal) {
    await this.cleanupMaterialSwitchLocks();
  }
  // ...
}

// 清理物料切换时的锁定
async cleanupMaterialSwitchLocks() {
  // 解锁当前条码、清理本地存储、重置状态
}
```

### 2. 页面刷新时的完整清理机制

#### 优化内容：
- **启动时清理**：在 `created()` 钩子中优先调用清理方法
- **验证清理**：检查存储的锁定信息是否与当前配置匹配
- **批量清理**：清理当前设备的所有过期锁定

#### 清理流程：
```javascript
async created() {
  // 1. 优先初始化设备信息
  this.initDeviceInfo();
  
  // 2. 清理过期锁定
  await this.cleanupExpiredLocks();
  
  // 3. 清理之前的锁定
  await this.cleanupPreviousLocks();
  
  // 4. 其他初始化...
}
```

### 3. 设备标识生成优化

#### 改进内容：
- **稳定设备ID**：基于设备特征生成稳定的唯一标识
- **本地持久化**：将设备ID保存到 localStorage 确保重启后一致
- **多层标识**：工位编号 > 设备特征哈希 > 随机标识

#### 设备ID生成策略：
```javascript
generateStableDeviceId() {
  // 1. 优先使用工位编号
  const workstationId = localStorage.getItem('workstationId');
  if (workstationId) {
    return `WS_${workstationId}`;
  }
  
  // 2. 使用设备特征生成稳定哈希
  const deviceFeatures = [
    navigator.userAgent,
    screen.width + 'x' + screen.height,
    screen.colorDepth,
    navigator.language,
    navigator.platform,
    new Date().getTimezoneOffset(),
    navigator.hardwareConcurrency || 'unknown'
  ];
  
  // 3. 生成12位哈希值
  const deviceHash = this.simpleHash(deviceFeatures.join('|'));
  return `DEV_${deviceHash}`;
}
```

### 4. 完善的锁定状态管理

#### 新增数据结构：
```javascript
// 当前锁定物料信息跟踪
currentLockedMaterial: {
  materialId: null,
  productionLineId: null,
  barcodeId: null
}
```

#### 状态验证方法：
```javascript
// 验证并清理不匹配的锁定
async validateAndCleanupLocks() {
  const lockedInfo = localStorage.getItem('lockedPackBarcode');
  // 检查物料ID和产线ID是否匹配
  // 不匹配则自动清理
}
```

### 5. 错误处理和兜底机制

#### 增强功能：
- **页面卸载处理**：使用 `sendBeacon` 确保解锁请求能发出
- **批量清理**：设备关闭时清理所有相关锁定
- **错误兜底**：解析失败时直接清理本地存储

#### 页面卸载优化：
```javascript
handlePageUnload(event) {
  // 1. 解锁当前条码
  if (this.packingBarcode && this.packingBarcode._id) {
    const unlockData = JSON.stringify({
      barcodeId: this.packingBarcode._id,
      ...this.deviceInfo
    });
    navigator.sendBeacon('/api/v1/unlockPackBarcode', unlockData);
  }
  
  // 2. 清理设备所有锁定
  if (this.deviceInfo.deviceIp || this.deviceInfo.sessionId) {
    const cleanupData = JSON.stringify(this.deviceInfo);
    navigator.sendBeacon('/api/v1/unlockAllPackBarcodes', cleanupData);
  }
}
```

## 多产线并发支持

### 设备标识唯一性保证：
1. **工位编号优先**：支持手动配置工位编号实现精确标识
2. **设备特征哈希**：基于硬件特征生成稳定的设备指纹
3. **会话级别隔离**：每次会话生成包含产线信息的唯一会话ID

### 产线隔离机制：
- 锁定信息包含产线ID，确保不同产线的条码锁定不互相影响
- 物料切换时自动清理不匹配产线的锁定
- 支持同一设备在不同产线间切换

## API调用路径修正

### 修正内容：
- 统一前端API调用路径为 `/api/v1/` 前缀
- 确保前后端路径一致性
- 新增状态检查API接口

### 接口列表：
- `POST /api/v1/getOrCreatePackBarcode` - 获取或创建装箱条码
- `POST /api/v1/unlockPackBarcode` - 解锁装箱条码
- `POST /api/v1/unlockAllPackBarcodes` - 批量解锁装箱条码
- `POST /api/v1/cleanExpiredLocks` - 清理过期锁定
- `GET /api/v1/checkPackBarcodeStatus` - 检查装箱条码状态

## 使用建议

### 部署配置：
1. **工位编号配置**：建议为每个工位配置唯一的工位编号
   ```javascript
   localStorage.setItem('workstationId', 'LINE01_WS001');
   ```

2. **定期清理**：建议定期调用清理过期锁定的接口
3. **监控检查**：可通过状态检查接口监控锁定情况

### 故障排查：
1. **查看设备ID**：检查 localStorage 中的 `deviceId`
2. **锁定信息**：检查 localStorage 中的 `lockedPackBarcode`
3. **控制台日志**：查看相关的清理和锁定日志

## 优化效果

1. **并发安全性**：彻底解决多产线装箱条码冲突问题
2. **状态一致性**：物料切换和页面刷新后状态正确清理
3. **用户体验**：减少因锁定冲突导致的操作失败
4. **系统稳定性**：通过完善的错误处理和兜底机制提升稳定性

## 注意事项

1. **向后兼容**：保持了与原有代码的兼容性
2. **性能影响**：新增的清理逻辑对性能影响极小
3. **存储空间**：本地存储增加了设备ID等少量数据
4. **网络请求**：页面卸载时会发送解锁请求，建议确保网络稳定

---

**版本**：1.0.0  
**更新时间**：2024年12月  
**维护人员**：系统开发团队 