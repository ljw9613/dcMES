# 直接查询多余产品的方法

## 问题托盘已确定

```
托盘编号: YDC-SN-1761614440131
托盘ID: 69001a68595b0a268d73c827
```

## 查询步骤

### 步骤1：使用 MongoDB Compass 或 Robo 3T 连接数据库

连接到 `dcmes` 数据库

### 步骤2：查询出库单中的23个条码

```javascript
db.warehouseontries.findOne(
  { 
    entryNo: "SCCK-MES-20251102-0001",
    "entryItems.palletCode": "YDC-SN-1761614440131"
  },
  { 
    "entryItems.$": 1 
  }
)
```

这会返回出库单中托盘 `YDC-SN-1761614440131` 的23个产品条码。

**记录这23个条码！**

### 步骤3：查询托盘中的24个条码

```javascript
db.materialpalletizings.findOne(
  { palletCode: "YDC-SN-1761614440131" },
  { palletBarcodes: 1 }
)
```

这会返回托盘中的24个条码及其状态。

### 步骤4：对比找出多余的1个

- 托盘中有24个条码
- 出库单中有23个条码
- **对比两个列表，找出那个在托盘中但不在出库单中的条码**

那个条码就是多余的产品！

## 快速查询脚本

如果你的服务器有 `mongosh` 命令（新版MongoDB客户端）：

```bash
mongosh dcmes --eval '
const entry = db.warehouseontries.findOne(
  { entryNo: "SCCK-MES-20251102-0001" }
);

const palletItem = entry.entryItems.find(
  item => item.palletCode === "YDC-SN-1761614440131"
);

const entryBarcodes = palletItem.palletBarcodes.map(b => b.barcode);

const pallet = db.materialpalletizings.findOne(
  { palletCode: "YDC-SN-1761614440131" }
);

const outBarcodes = pallet.palletBarcodes
  .filter(b => b.outWarehouseStatus === "COMPLETED")
  .map(b => b.barcode);

const extraBarcodes = outBarcodes.filter(
  code => !entryBarcodes.includes(code)
);

print("出库单中的条码数: " + entryBarcodes.length);
print("托盘中已出库的条码数: " + outBarcodes.length);
print("");
print("多余的条码:");
extraBarcodes.forEach(code => print("  - " + code));
'
```

## 修复建议

找到多余的条码后，有两个选择：

### 选择1：调整应出库数量（推荐）⭐

既然1001个产品都已经出库了，就调整应出库数量：

```javascript
db.warehouseontries.updateOne(
  { entryNo: "SCCK-MES-20251102-0001" },
  { 
    $set: { 
      outboundQuantity: 1001,
      updateAt: new Date()
    } 
  }
)
```

### 选择2：删除多余的条码

如果确定只应该出库1000个，需要：

1. **从出库单中删除多余的条码**
```javascript
db.warehouseontries.updateOne(
  { 
    entryNo: "SCCK-MES-20251102-0001",
    "entryItems.palletCode": "YDC-SN-1761614440131"
  },
  {
    $pull: {
      "entryItems.$.palletBarcodes": {
        barcode: "多余的条码"  // 替换为实际条码
      }
    }
  }
)
```

2. **更新托盘项的数量**
```javascript
db.warehouseontries.updateOne(
  { 
    entryNo: "SCCK-MES-20251102-0001",
    "entryItems.palletCode": "YDC-SN-1761614440131"
  },
  {
    $set: {
      "entryItems.$.quantity": 23
    }
  }
)
```

3. **恢复托盘中条码的状态**
```javascript
db.materialpalletizings.updateOne(
  { palletCode: "YDC-SN-1761614440131" },
  {
    $set: {
      "palletBarcodes.$[elem].outWarehouseStatus": "PENDING",
      "palletBarcodes.$[elem].outWarehouseTime": null,
      "palletBarcodes.$[elem].outWarehouseBy": null,
      "inWarehouseStatus": "PART_OUT_WAREHOUSE"
    }
  },
  {
    arrayFilters: [{ "elem.barcode": "多余的条码" }]  // 替换为实际条码
  }
)
```

4. **运行修复脚本重新计算**
```bash
node scripts/fixWarehouseEntryQuantity.js --entryNo SCCK-MES-20251102-0001
```

## 推荐方案

**强烈推荐选择1（调整应出库数量）**

理由：
- ✅ 简单快捷
- ✅ 不破坏已有数据
- ✅ 符合实际情况（1001个确实都出库了）
- ✅ 无需复杂的数据恢复操作

只需一条命令：
```bash
# 使用 mongosh
mongosh dcmes --eval 'db.warehouseontries.updateOne({entryNo:"SCCK-MES-20251102-0001"},{$set:{outboundQuantity:1001,updateAt:new Date()}})'

# 或使用旧版 mongo
mongo dcmes --eval 'db.warehouseontries.updateOne({entryNo:"SCCK-MES-20251102-0001"},{$set:{outboundQuantity:1001,updateAt:new Date()}})'
```

修复后验证：
```bash
node scripts/checkWarehouseEntryQuantity.js SCCK-MES-20251102-0001
```

应该显示：`✓ 未发现问题`








