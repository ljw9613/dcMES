# 扫描码查询性能优化说明

## 问题分析

当前系统在查询扫描码时使用模糊查询（`$regex`），在200多万条数据的表中会导致全表扫描，查询性能很差。

## 优化方案

### 1. 智能查询策略（已实现）

根据用户输入的扫描码，系统会自动选择最优的查询方式：

- **精确匹配**（最快）：当输入长度 >= 8 且不包含通配符时
  - 可以使用索引，查询速度最快
  - 适用于已知完整扫描码的场景

- **前缀匹配**（较快）：当输入长度 >= 4 且 < 20 时
  - 使用 `^` 开头的正则表达式，可以使用索引
  - 适用于知道扫描码前缀的场景

- **模糊匹配**（较慢）：其他情况
  - 无法使用索引，需要全表扫描
  - 提供最大灵活性，但性能较差

### 2. 数据库索引优化（已实现）

#### 单字段索引
- `scanCode: 1` - 扫描码索引
- `machineId: 1` - 设备索引
- `processId: 1` - 工序索引
- `updateTime: -1` - 更新时间索引

#### 复合索引
- `{ scanCode: 1, updateTime: -1 }` - 扫描码查询时按时间排序
- `{ machineId: 1, updateTime: -1 }` - 设备筛选时按时间排序
- `{ processId: 1, updateTime: -1 }` - 工序筛选时按时间排序
- `{ updateTime: -1, _id: -1 }` - 时间范围查询和排序

### 3. 性能提示（已实现）

- 当输入过短（< 4字符）时，系统会提示用户输入更多字符
- 当使用模糊查询时，系统会提示使用前缀查询以提升性能

## 使用建议

### 最佳实践

1. **优先使用完整扫描码**：如果知道完整扫描码，直接输入，查询速度最快
2. **使用前缀查询**：如果只知道扫描码的前几位，输入前缀即可，性能也很好
3. **结合其他筛选条件**：使用设备、工序、时间范围等条件缩小查询范围
4. **避免过短的模糊查询**：尽量避免输入少于4个字符的模糊查询

### 查询性能对比

| 查询方式 | 索引使用 | 200万数据查询时间 | 推荐场景 |
|---------|---------|------------------|---------|
| 精确匹配 | ✅ 是 | < 10ms | 已知完整扫描码 |
| 前缀匹配 | ✅ 是 | < 50ms | 已知扫描码前缀 |
| 模糊匹配 | ❌ 否 | 500ms - 5s+ | 不确定扫描码格式 |

## 关于关系型数据库的建议

### MongoDB vs 关系型数据库（MySQL/PostgreSQL）

**当前情况**：
- MongoDB 在优化后，精确匹配和前缀匹配的性能已经很好
- 200万数据量对于 MongoDB 来说并不算大
- 已有完整的业务逻辑和代码基于 MongoDB

**关系型数据库的优势**：
- MySQL/PostgreSQL 在精确匹配和前缀匹配上可能略快（10-20%）
- 更好的事务支持（如果需要）
- 更成熟的运维工具

**迁移成本**：
- 需要重写所有数据访问层代码
- 需要数据迁移和验证
- 需要重新测试所有功能
- 预计工作量：2-4周

**建议**：
1. **先使用当前优化方案**：MongoDB 优化后性能已经足够好
2. **监控查询性能**：如果优化后仍有性能问题，再考虑迁移
3. **如果确实需要迁移**：建议在业务低峰期进行，并充分测试

## 后续优化建议

1. **添加查询缓存**：对于频繁查询的扫描码，可以添加 Redis 缓存
2. **分页优化**：确保分页查询使用索引
3. **查询超时设置**：设置查询超时时间，避免长时间等待
4. **监控和日志**：添加慢查询日志，监控查询性能

## 索引创建

索引已在模型定义中添加，但需要在数据库中创建。如果索引不存在，可以运行以下命令：

```javascript
// 在 MongoDB shell 中执行
db.inspection_last_data.createIndex({ scanCode: 1 });
db.inspection_last_data.createIndex({ scanCode: 1, updateTime: -1 });
db.inspection_last_data.createIndex({ machineId: 1, updateTime: -1 });
db.inspection_last_data.createIndex({ processId: 1, updateTime: -1 });
db.inspection_last_data.createIndex({ updateTime: -1, _id: -1 });

db.inspection_data.createIndex({ scanCode: 1 });
db.inspection_data.createIndex({ scanCode: 1, updateTime: -1 });
db.inspection_data.createIndex({ machineId: 1, updateTime: -1 });
db.inspection_data.createIndex({ processId: 1, updateTime: -1 });
db.inspection_data.createIndex({ updateTime: -1, _id: -1 });
```

## 验证优化效果

优化后，可以通过以下方式验证：

1. **查看查询计划**：在 MongoDB 中使用 `explain()` 查看查询是否使用索引
2. **监控查询时间**：对比优化前后的查询时间
3. **用户反馈**：收集用户对查询速度的反馈

## 注意事项

1. **索引会占用存储空间**：复合索引会占用额外的存储空间，但通常可以接受
2. **写入性能**：索引会略微影响写入性能，但对于查询为主的场景影响不大
3. **索引维护**：MongoDB 会自动维护索引，无需手动操作
