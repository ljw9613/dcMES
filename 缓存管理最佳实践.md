# 缓存管理最佳实践

## 📋 缓存影响说明

### ✅ 实时生效（无缓存）

以下数据修改后**立即生效**，无需清除缓存：

| 数据类型 | 说明 | 影响范围 |
|---------|------|---------|
| 工艺（Craft） | 物料的工艺路线 | 所有使用该工艺的新建流程 |
| 工序（ProcessStep） | 工艺中的工序步骤 | 工序顺序、名称、类型等 |
| 工序物料（ProcessMaterials） | 工序关联的物料 | 工序需要扫描的物料列表 |
| 物料信息（Material） | K3物料基础信息 | 物料名称、规格等 |
| 工单信息（WorkOrder） | 生产工单 | 工单状态、数量等 |

**示例场景：**
```javascript
// ✅ 场景1：调整工序顺序
// 在 ProcessStep 表中修改 sort 字段
// 新创建的流程会立即使用新顺序
await ProcessStep.updateOne(
  { _id: processStepId },
  { $set: { sort: 5 } }
);
// 无需清除缓存，立即生效 ✅

// ✅ 场景2：修改工序关联的物料
// 在 ProcessMaterials 表中添加/删除物料
await ProcessMaterials.create({
  processStepId: 'xxx',
  materialId: 'yyy',
  quantity: 1
});
// 无需清除缓存，立即生效 ✅

// ✅ 场景3：修改工艺信息
// 在 Craft 表中修改工艺
await Craft.updateOne(
  { _id: craftId },
  { $set: { craftName: '新工艺名称' } }
);
// 无需清除缓存，立即生效 ✅
```

### ⚠️ 需要清除缓存（5分钟延迟）

以下数据修改后需要**手动清除缓存**，否则最多5分钟后生效：

| 数据类型 | 说明 | 影响范围 | 解决方案 |
|---------|------|---------|---------|
| 条码规则（BarcodeRule） | 全局条码验证规则 | 所有条码验证 | 清除所有缓存 |
| 产品条码规则（ProductBarcodeRule） | 特定产品的条码规则 | 该产品的条码验证 | 清除该物料缓存 |

**示例场景：**
```javascript
// ⚠️ 场景4：修改条码规则（需要清除缓存）
const MaterialProcessFlowService = require('./services/materialProcessFlowService');

// 1. 修改全局条码规则
await BarcodeRule.updateOne(
  { _id: ruleId },
  { $set: { validationRules: [...] } }
);

// 2. 清除所有缓存（立即生效）
MaterialProcessFlowService.clearBarcodeRuleCache();
// ✅ 已清除所有条码规则缓存

// ⚠️ 场景5：修改产品特定的条码规则
// 1. 修改产品条码规则
await ProductBarcodeRule.updateOne(
  { productId: materialId },
  { $set: { barcodeRule: ruleId } }
);

// 2. 清除该物料的缓存（立即生效）
MaterialProcessFlowService.clearBarcodeRuleCache(materialId);
// ✅ 已清除物料 xxx 的条码规则缓存
```

---

## 🔧 缓存管理 API

### 1. 清除单个物料的缓存

```javascript
const MaterialProcessFlowService = require('./services/materialProcessFlowService');

// 清除指定物料的条码规则缓存
const result = MaterialProcessFlowService.clearBarcodeRuleCache('物料ID');

console.log(result);
// {
//   success: true,
//   message: '已清除物料 xxx 的条码规则缓存',
//   type: 'single',
//   materialId: 'xxx'
// }
```

### 2. 批量清除多个物料的缓存

```javascript
// 清除多个物料的缓存
const materialIds = ['物料ID1', '物料ID2', '物料ID3'];
const result = MaterialProcessFlowService.clearBarcodeRuleCache(materialIds);

console.log(result);
// {
//   success: true,
//   message: '已清除 3 个物料的条码规则缓存',
//   type: 'batch',
//   count: 3
// }
```

### 3. 清除所有缓存

```javascript
// 清除所有条码规则缓存
const result = MaterialProcessFlowService.clearBarcodeRuleCache();

console.log(result);
// {
//   success: true,
//   message: '已清除所有条码规则缓存',
//   type: 'all'
// }
```

### 4. 查看缓存统计

```javascript
// 获取缓存统计信息
const stats = MaterialProcessFlowService.getBarcodeRuleCacheStats();

console.log(stats);
// {
//   total: 15,        // 总缓存数
//   active: 12,       // 未过期的
//   expired: 3,       // 已过期的
//   cacheTimeout: '300秒'  // 过期时间
// }
```

---

## 💡 实践示例

### 示例1：条码规则管理接口

```javascript
// routes/barcodeRuleRoutes.js
const express = require('express');
const router = express.Router();
const BarcodeRule = require('../model/project/barcodeRule');
const MaterialProcessFlowService = require('../services/materialProcessFlowService');

// 更新条码规则
router.put('/barcode-rule/:id', async (req, res) => {
  try {
    // 1. 更新数据库
    const rule = await BarcodeRule.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true }
    );

    if (!rule) {
      return res.status(404).json({ message: '规则不存在' });
    }

    // 2. 清除缓存（关键步骤！）
    MaterialProcessFlowService.clearBarcodeRuleCache();

    res.json({
      success: true,
      message: '条码规则更新成功，缓存已清除',
      data: rule
    });

  } catch (error) {
    console.error('更新条码规则失败:', error);
    res.status(500).json({ message: error.message });
  }
});

module.exports = router;
```

### 示例2：产品条码规则管理

```javascript
// routes/productBarcodeRuleRoutes.js
const express = require('express');
const router = express.Router();
const ProductBarcodeRule = require('../model/project/productBarcodeRule');
const MaterialProcessFlowService = require('../services/materialProcessFlowService');

// 更新产品条码规则
router.put('/product-barcode-rule/:productId', async (req, res) => {
  try {
    const { productId } = req.params;

    // 1. 更新数据库
    const rule = await ProductBarcodeRule.findOneAndUpdate(
      { productId },
      req.body,
      { new: true, upsert: true }
    );

    // 2. 清除该产品的缓存（关键步骤！）
    MaterialProcessFlowService.clearBarcodeRuleCache(productId);

    res.json({
      success: true,
      message: '产品条码规则更新成功，缓存已清除',
      data: rule
    });

  } catch (error) {
    console.error('更新产品条码规则失败:', error);
    res.status(500).json({ message: error.message });
  }
});

// 批量更新产品条码规则
router.post('/product-barcode-rule/batch', async (req, res) => {
  try {
    const { updates } = req.body; // [{ productId, ruleId }, ...]
    
    // 1. 批量更新数据库
    const promises = updates.map(item =>
      ProductBarcodeRule.findOneAndUpdate(
        { productId: item.productId },
        { barcodeRule: item.ruleId },
        { new: true, upsert: true }
      )
    );
    const results = await Promise.all(promises);

    // 2. 批量清除缓存（关键步骤！）
    const productIds = updates.map(u => u.productId);
    const clearResult = MaterialProcessFlowService.clearBarcodeRuleCache(productIds);

    res.json({
      success: true,
      message: '批量更新成功',
      updated: results.length,
      cacheCleared: clearResult.count
    });

  } catch (error) {
    console.error('批量更新失败:', error);
    res.status(500).json({ message: error.message });
  }
});

module.exports = router;
```

### 示例3：缓存管理接口（管理员用）

```javascript
// routes/cacheManagementRoutes.js
const express = require('express');
const router = express.Router();
const MaterialProcessFlowService = require('../services/materialProcessFlowService');

// 查看缓存统计
router.get('/cache/stats', (req, res) => {
  try {
    const stats = MaterialProcessFlowService.getBarcodeRuleCacheStats();
    res.json({
      success: true,
      data: stats
    });
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// 清除所有缓存
router.post('/cache/clear', (req, res) => {
  try {
    const result = MaterialProcessFlowService.clearBarcodeRuleCache();
    res.json(result);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

// 清除指定物料缓存
router.post('/cache/clear/:materialId', (req, res) => {
  try {
    const result = MaterialProcessFlowService.clearBarcodeRuleCache(
      req.params.materialId
    );
    res.json(result);
  } catch (error) {
    res.status(500).json({ message: error.message });
  }
});

module.exports = router;
```

---

## 📊 PM2 多进程环境

### 问题说明

在 PM2 多进程（cluster）模式下，每个进程有独立的缓存实例：

```
进程 0: [缓存A]
进程 1: [缓存B]  ← 各进程缓存独立
进程 2: [缓存C]
进程 3: [缓存D]
```

**影响：** 清除缓存时只会清除当前进程的缓存。

### 解决方案1：使用 PM2 消息通信

```javascript
// 在缓存管理方法中添加
static clearBarcodeRuleCache(materialId = null) {
  try {
    // 1. 清除当前进程的缓存
    if (materialId === null) {
      this.barcodeRuleCache.clear();
    } else if (Array.isArray(materialId)) {
      this.barcodeRuleCache.clearBatch(materialId);
    } else {
      this.barcodeRuleCache.clear(materialId);
    }

    // 2. 通知其他进程清除缓存（PM2 cluster 模式）
    if (process.send) {
      process.send({
        type: 'clear-cache',
        data: { materialId }
      });
    }

    return { success: true, message: '缓存已清除' };
  } catch (error) {
    console.error('清除缓存失败:', error);
    return { success: false, message: error.message };
  }
}

// 在 server.js 中监听消息
process.on('message', (msg) => {
  if (msg.type === 'clear-cache') {
    const MaterialProcessFlowService = require('./services/materialProcessFlowService');
    MaterialProcessFlowService.clearBarcodeRuleCache(msg.data.materialId);
    console.log('收到清除缓存消息:', msg.data);
  }
});
```

### 解决方案2：使用 Redis（推荐生产环境）

如果规则更新频繁或需要进程间共享缓存：

```javascript
// 使用 Redis 替代内存缓存
const Redis = require('ioredis');
const redis = new Redis({
  host: '127.0.0.1',
  port: 6379,
  db: 0,
  keyPrefix: 'dcmes:barcode_rule:'
});

class BarcodeRuleCache {
  async get(materialId) {
    const key = materialId.toString();
    const cached = await redis.get(key);
    if (cached) {
      return JSON.parse(cached);
    }
    return null;
  }

  async set(materialId, rules) {
    const key = materialId.toString();
    await redis.setex(key, 300, JSON.stringify(rules)); // 5分钟过期
  }

  async clear(materialId) {
    if (materialId) {
      await redis.del(materialId.toString());
    } else {
      const keys = await redis.keys('*');
      if (keys.length > 0) {
        await redis.del(...keys);
      }
    }
  }
}
```

---

## ⚠️ 注意事项

### 1. 何时需要清除缓存

| 操作 | 是否需要清除缓存 |
|------|----------------|
| 新增/修改/删除条码规则 | ✅ 需要 |
| 新增/修改产品条码规则关联 | ✅ 需要 |
| 修改工艺路线 | ❌ 不需要 |
| 修改工序信息 | ❌ 不需要 |
| 修改工序物料关系 | ❌ 不需要 |
| 修改物料基础信息 | ❌ 不需要 |

### 2. 缓存清除时机

**推荐做法：**
```javascript
// 1. 在事务中一起执行
const session = await mongoose.startSession();
session.startTransaction();
try {
  // 更新数据库
  await BarcodeRule.updateOne({...}, {...}, { session });
  
  // 提交事务
  await session.commitTransaction();
  
  // 清除缓存（事务成功后）
  MaterialProcessFlowService.clearBarcodeRuleCache();
  
} catch (error) {
  await session.abortTransaction();
  throw error;
} finally {
  session.endSession();
}
```

**不推荐：**
```javascript
// ❌ 先清除缓存再更新数据库（可能导致短暂不一致）
MaterialProcessFlowService.clearBarcodeRuleCache();
await BarcodeRule.updateOne({...});
```

### 3. 性能考虑

- ✅ 5分钟缓存已经足够平衡性能和数据新鲜度
- ✅ 自动清理机制每10分钟运行一次
- ✅ 规则更新不频繁时，缓存命中率可达 90% 以上
- ⚠️ 如果规则更新非常频繁（每分钟多次），考虑缩短缓存时间

---

## 📝 总结

1. **工艺和工序调整**：✅ 实时生效，无延迟
2. **条码规则调整**：⚠️ 需要手动清除缓存或等待最多5分钟
3. **推荐做法**：在规则更新接口中调用 `clearBarcodeRuleCache()`
4. **PM2 集群**：单进程缓存，可通过进程通信或 Redis 解决
5. **监控建议**：定期查看缓存统计，确保缓存正常工作

**最佳实践口诀：**
> 改规则要清缓存，改工艺不用管！
> 清缓存在更新后，事务成功再执行！

---

## 🔗 相关文档

- [性能优化实施总结.md](./性能优化实施总结.md)
- [PM2部署指南.md](./PM2部署指南.md)
- [materialProcessFlowService性能优化分析报告.md](./materialProcessFlowService性能优化分析报告.md)

