# å·¥å•æŠ•å…¥é‡å¹¶å‘å®‰å…¨æ”¹è¿›æ–¹æ¡ˆ

## æ”¹è¿›æ–¹æ¡ˆ1: é”ç»­æœŸå¤±è´¥æ£€æµ‹ä¸ä»»åŠ¡ç»ˆæ­¢

### å½“å‰é—®é¢˜
```javascript
// å½“å‰ä»£ç  - queueService.js ç¬¬639-641è¡Œ
const extendLockInterval = setInterval(async () => {
  await workOrderLockManager.extendLock(workOrderId, workerId);
}, 8000); // æ‰©å±•é”ä½†ä¸æ£€æŸ¥ç»“æœ âŒ
```

**é—®é¢˜**: å¦‚æœç½‘ç»œå»¶è¿Ÿå¯¼è‡´é”ç»­æœŸå¤±è´¥ï¼Œä»»åŠ¡ä»ä¼šç»§ç»­æ‰§è¡Œï¼Œå¯èƒ½å¯¼è‡´é‡å¤æ‰£å‡ã€‚

### æ”¹è¿›ä»£ç 

```javascript
// æ”¹è¿›åçš„ä»£ç 
static initializeWorkOrderProcessor() {
  console.log('ğŸ”§ åˆå§‹åŒ–å·¥å•æ•°é‡æ›´æ–°å¤„ç†å™¨...');
  
  workOrderQueue.process('update-quantity', 5, async (job) => {
    const startTime = Date.now();
    const workerId = `worker_${process.pid}_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    const { workOrderId, type, quantity, logContext, requestId } = job.data;

    let lockAcquired = false;
    let lockValid = true; // æ–°å¢ï¼šé”æœ‰æ•ˆæ€§æ ‡è®°
    let extendLockInterval = null; // æ–°å¢ï¼šå®šæ—¶å™¨å¼•ç”¨

    try {
      console.log(`ğŸ“ å¼€å§‹å¤„ç†å·¥å•æ›´æ–°ä»»åŠ¡: ${job.id}, WorkOrder: ${workOrderId}, Type: ${type}, Quantity: ${quantity}, Worker: ${workerId}`);

      await job.progress(5);

      // è·å–é”çš„é€»è¾‘ä¿æŒä¸å˜
      console.log(`ğŸ” å°è¯•è·å–å·¥å•é”: ${workOrderId}`);
      const lockStartTime = Date.now();
      const maxLockWaitTime = 3000;
      
      while (Date.now() - lockStartTime < maxLockWaitTime) {
        lockAcquired = await workOrderLockManager.acquireLock(workOrderId, workerId);
        if (lockAcquired) {
          break;
        }
        
        const lockStatus = await workOrderLockManager.getLockStatus(workOrderId);
        console.log(`â³ ç­‰å¾…å·¥å•é”é‡Šæ”¾: ${workOrderId}, å½“å‰æŒæœ‰è€…: ${lockStatus.owner}, å‰©ä½™æ—¶é—´: ${lockStatus.remainingTime}ms`);
        
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      if (!lockAcquired) {
        throw new Error(`æ— æ³•è·å–å·¥å•é”: ${workOrderId}ï¼Œå¯èƒ½å­˜åœ¨å¹¶å‘å†²çªæˆ–é”è¶…æ—¶`);
      }

      await job.progress(10);

      // å¯¼å…¥æœåŠ¡
      const MaterialProcessFlowService = require('./materialProcessFlowService');
      
      await job.progress(30);
      
      // ============= å…³é”®æ”¹è¿›ï¼šç›‘æ§é”çš„æœ‰æ•ˆæ€§ =============
      let lockExtensionFailureCount = 0; // é”æ‰©å±•å¤±è´¥è®¡æ•°
      const maxLockExtensionFailures = 2; // å…è®¸çš„æœ€å¤§å¤±è´¥æ¬¡æ•°
      
      extendLockInterval = setInterval(async () => {
        try {
          // æ£€æŸ¥é”æ‰©å±•ç»“æœ
          const extended = await workOrderLockManager.extendLock(workOrderId, workerId);
          
          if (!extended) {
            lockExtensionFailureCount++;
            console.error(`ğŸš¨ é”æ‰©å±•å¤±è´¥ (${lockExtensionFailureCount}/${maxLockExtensionFailures}): ${workOrderId} by ${workerId}`);
            
            // å¦‚æœè¿ç»­å¤±è´¥è¶…è¿‡é˜ˆå€¼ï¼Œæ ‡è®°é”ä¸ºæ— æ•ˆ
            if (lockExtensionFailureCount >= maxLockExtensionFailures) {
              lockValid = false;
              clearInterval(extendLockInterval);
              console.error(`ğŸš¨ é”å·²å¤±æ•ˆï¼Œå°†ç»ˆæ­¢ä»»åŠ¡: ${workOrderId}`);
              
              // è®°å½•å‘Šè­¦
              await this.logLockFailure(workOrderId, workerId, job.id);
            }
          } else {
            // æ‰©å±•æˆåŠŸï¼Œé‡ç½®å¤±è´¥è®¡æ•°
            lockExtensionFailureCount = 0;
            console.log(`âœ… é”æ‰©å±•æˆåŠŸ: ${workOrderId} by ${workerId}`);
          }
        } catch (error) {
          lockExtensionFailureCount++;
          console.error(`âŒ é”æ‰©å±•å¼‚å¸¸ (${lockExtensionFailureCount}/${maxLockExtensionFailures}):`, error);
          
          if (lockExtensionFailureCount >= maxLockExtensionFailures) {
            lockValid = false;
            clearInterval(extendLockInterval);
          }
        }
      }, 5000); // æ”¹ä¸º5ç§’æ‰©å±•ä¸€æ¬¡ï¼Œæ›´åŠæ—¶åœ°æ£€æµ‹é—®é¢˜
      
      try {
        // ============= æ‰§è¡Œå‰æ£€æŸ¥é”æ˜¯å¦æœ‰æ•ˆ =============
        if (!lockValid) {
          throw new Error(`é”å·²å¤±æ•ˆï¼Œç»ˆæ­¢æ›´æ–°æ“ä½œ: ${workOrderId}`);
        }
        
        // æ‰§è¡Œå®é™…çš„æ•°æ®åº“æ›´æ–°æ“ä½œ
        const result = await MaterialProcessFlowService._executeWorkOrderQuantityUpdate(
          workOrderId, 
          type, 
          quantity, 
          logContext
        );

        clearInterval(extendLockInterval);
        extendLockInterval = null;

        const duration = Date.now() - startTime;
        
        // ============= ä»»åŠ¡å®Œæˆåå†æ¬¡æ£€æŸ¥é”æœ‰æ•ˆæ€§ =============
        if (!lockValid) {
          console.error(`âš ï¸ ä»»åŠ¡å®Œæˆä½†é”åœ¨æ‰§è¡ŒæœŸé—´å¤±æ•ˆ: ${workOrderId}, å¯èƒ½å­˜åœ¨å¹¶å‘é£é™©`);
          // è®°å½•å‘Šè­¦ï¼Œä½†ä¸å›æ»šï¼ˆå› ä¸ºæ›´æ–°å·²å®Œæˆï¼‰
          await this.logLockWarning(workOrderId, workerId, job.id, duration);
        }

        console.log(`âœ… å·¥å•æ›´æ–°ä»»åŠ¡å®Œæˆ: ${job.id}, WorkOrder: ${workOrderId}, è€—æ—¶: ${duration}ms, Worker: ${workerId}`);

        await job.progress(100);
        
        return {
          success: true,
          workOrderId,
          type,
          quantity,
          result,
          duration,
          workerId,
          lockValid, // è¿”å›é”çš„æœ‰æ•ˆæ€§çŠ¶æ€
          processedAt: new Date().toISOString()
        };
      } finally {
        if (extendLockInterval) {
          clearInterval(extendLockInterval);
        }
      }
      
    } catch (error) {
      const duration = Date.now() - startTime;
      console.error(`âŒ å·¥å•æ›´æ–°ä»»åŠ¡å¤±è´¥: ${job.id}, WorkOrder: ${workOrderId}, è€—æ—¶: ${duration}ms, Worker: ${workerId}`, error);

      await job.progress(100);
      
      throw new Error(`å·¥å•${workOrderId}æ›´æ–°å¤±è´¥: ${error.message}`);
    } finally {
      // æ¸…ç†å®šæ—¶å™¨
      if (extendLockInterval) {
        clearInterval(extendLockInterval);
      }
      
      // é‡Šæ”¾é”
      if (lockAcquired) {
        await workOrderLockManager.releaseLock(workOrderId, workerId);
      }
    }
  });
}

// ============= æ–°å¢è¾…åŠ©æ–¹æ³• =============

/**
 * è®°å½•é”å¤±æ•ˆå‘Šè­¦
 */
static async logLockFailure(workOrderId, workerId, jobId) {
  try {
    const alertLog = {
      type: 'LOCK_FAILURE',
      workOrderId,
      workerId,
      jobId,
      timestamp: new Date(),
      message: 'é”æ‰©å±•å¤±è´¥è¶…è¿‡é˜ˆå€¼ï¼Œä»»åŠ¡å·²ç»ˆæ­¢',
      severity: 'CRITICAL'
    };
    
    console.error('ğŸš¨ é”å¤±æ•ˆå‘Šè­¦:', JSON.stringify(alertLog));
    
    // å¯ä»¥å‘é€åˆ°ç›‘æ§ç³»ç»Ÿæˆ–å†™å…¥ä¸“é—¨çš„å‘Šè­¦æ—¥å¿—
    // await MonitoringService.sendAlert(alertLog);
  } catch (error) {
    console.error('è®°å½•é”å¤±æ•ˆå‘Šè­¦å¤±è´¥:', error);
  }
}

/**
 * è®°å½•é”æœ‰æ•ˆæ€§è­¦å‘Š
 */
static async logLockWarning(workOrderId, workerId, jobId, duration) {
  try {
    const warningLog = {
      type: 'LOCK_WARNING',
      workOrderId,
      workerId,
      jobId,
      duration,
      timestamp: new Date(),
      message: 'ä»»åŠ¡æ‰§è¡ŒæœŸé—´é”å¤±æ•ˆï¼Œå¯èƒ½å­˜åœ¨å¹¶å‘é£é™©',
      severity: 'WARNING'
    };
    
    console.warn('âš ï¸ é”æœ‰æ•ˆæ€§è­¦å‘Š:', JSON.stringify(warningLog));
    
    // å¯ä»¥å‘é€åˆ°ç›‘æ§ç³»ç»Ÿ
    // await MonitoringService.sendAlert(warningLog);
  } catch (error) {
    console.error('è®°å½•é”è­¦å‘Šå¤±è´¥:', error);
  }
}
```

---

## æ”¹è¿›æ–¹æ¡ˆ2: å®ç°å¹‚ç­‰æ€§æœºåˆ¶

### å½“å‰é—®é¢˜
å¦‚æœé”å¤±æ•ˆå¯¼è‡´é‡å¤æ‰§è¡Œï¼Œæ— æ³•è¯†åˆ«å’Œé˜»æ­¢é‡å¤çš„æ›´æ–°è¯·æ±‚ã€‚

### æ•°æ®æ¨¡å‹

é¦–å…ˆåˆ›å»ºæ›´æ–°æ—¥å¿—æ¨¡å‹ï¼š

```javascript
// model/project/workOrderUpdateLog.js

const mongoose = require('mongoose');
const Schema = mongoose.Schema;

const workOrderUpdateLogSchema = new Schema({
  // å”¯ä¸€è¯·æ±‚IDï¼ˆç”¨äºå¹‚ç­‰æ€§æ§åˆ¶ï¼‰
  requestId: {
    type: String,
    required: true,
    unique: true, // å”¯ä¸€ç´¢å¼•ï¼Œé˜²æ­¢é‡å¤
    index: true,
  },
  
  // å·¥å•ä¿¡æ¯
  workOrderId: {
    type: Schema.Types.ObjectId,
    ref: 'production_plan_work_order',
    required: true,
    index: true,
  },
  workOrderNo: String,
  
  // æ›´æ–°ç±»å‹å’Œæ•°é‡
  type: {
    type: String,
    enum: ['input', 'output'],
    required: true,
  },
  quantity: {
    type: Number,
    required: true,
  },
  
  // æ›´æ–°å‰åçš„å€¼
  beforeValue: Number,
  afterValue: Number,
  
  // å¤„ç†ä¿¡æ¯
  workerId: String,
  jobId: String,
  processedAt: {
    type: Date,
    default: Date.now,
    index: true,
  },
  duration: Number, // å¤„ç†è€—æ—¶ï¼ˆæ¯«ç§’ï¼‰
  
  // ä¸Šä¸‹æ–‡ä¿¡æ¯
  logContext: {
    relatedBarcode: String,
    barcodeOperation: String,
    operatorId: String,
    processStepId: String,
    processName: String,
    processCode: String,
    reason: String,
    remark: String,
    ipAddress: String,
    userAgent: String,
    source: String,
    isAutomatic: Boolean,
  },
  
  // çŠ¶æ€ä¿¡æ¯
  status: {
    type: String,
    enum: ['SUCCESS', 'FAILED', 'DUPLICATE'],
    default: 'SUCCESS',
  },
  errorMessage: String,
  
  // æ•°æ®ä¸€è‡´æ€§æ ¡éªŒ
  isVerified: {
    type: Boolean,
    default: false,
  },
  verifiedAt: Date,
}, {
  timestamps: true,
  collection: 'work_order_update_logs'
});

// å¤åˆç´¢å¼•ï¼ˆä¼˜åŒ–æŸ¥è¯¢æ€§èƒ½ï¼‰
workOrderUpdateLogSchema.index({ workOrderId: 1, processedAt: -1 });
workOrderUpdateLogSchema.index({ status: 1, processedAt: -1 });

// TTLç´¢å¼•ï¼ˆå¯é€‰ï¼š30å¤©åè‡ªåŠ¨åˆ é™¤æ—¥å¿—ï¼‰
workOrderUpdateLogSchema.index({ processedAt: 1 }, { expireAfterSeconds: 30 * 24 * 60 * 60 });

module.exports = mongoose.model('work_order_update_log', workOrderUpdateLogSchema);
```

### æ”¹è¿›çš„æ‰§è¡Œæ–¹æ³•

```javascript
// materialProcessFlowService.js
// ä¿®æ”¹ _executeWorkOrderQuantityUpdate æ–¹æ³•

static async _executeWorkOrderQuantityUpdate(
  workOrderId,
  type,
  quantity = 1,
  logContext = {}
) {
  // ä»logContextä¸­æå–requestIdï¼Œå¦‚æœæ²¡æœ‰åˆ™ç”Ÿæˆä¸€ä¸ª
  const requestId = logContext.requestId || 
    `${workOrderId}_${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  
  try {
    // ============= å¹‚ç­‰æ€§æ£€æŸ¥ =============
    const WorkOrderUpdateLog = require('../model/project/workOrderUpdateLog');
    
    // æ£€æŸ¥æ˜¯å¦å·²ç»å¤„ç†è¿‡è¿™ä¸ªè¯·æ±‚
    const existingLog = await WorkOrderUpdateLog.findOne({ 
      requestId,
      status: 'SUCCESS' 
    });
    
    if (existingLog) {
      console.log(`ğŸ” è¯·æ±‚å·²å¤„ç†ï¼Œè·³è¿‡é‡å¤æ‰§è¡Œ: ${requestId}`);
      console.log(`   åŸå¤„ç†æ—¶é—´: ${existingLog.processedAt}`);
      console.log(`   åŸå¤„ç†ç»“æœ: ${existingLog.beforeValue} â†’ ${existingLog.afterValue}`);
      
      // è®°å½•é‡å¤è¯·æ±‚
      await WorkOrderUpdateLog.create({
        requestId: `${requestId}_DUPLICATE_${Date.now()}`,
        workOrderId,
        type,
        quantity,
        status: 'DUPLICATE',
        workerId: logContext.workerId,
        jobId: logContext.jobId,
        logContext,
        errorMessage: `é‡å¤è¯·æ±‚ï¼ŒåŸè¯·æ±‚ID: ${requestId}`,
      });
      
      return {
        success: true,
        isDuplicate: true,
        originalLog: existingLog,
        message: 'è¯·æ±‚å·²å¤„ç†è¿‡ï¼Œè·³è¿‡é‡å¤æ‰§è¡Œ',
      };
    }
    
    // ============= æ‰§è¡Œæ›´æ–°ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰ =============
    if (!workOrderId) {
      console.log("æœªæä¾›å·¥å•IDï¼Œè·³è¿‡æ›´æ–°å·¥å•æ•°é‡");
      throw new Error("æœªæä¾›å·¥å•ID");
    }

    const updateField = type === "input" ? "inputQuantity" : "outputQuantity";

    // è·å–æ›´æ–°å‰çš„å·¥å•ä¿¡æ¯
    const beforeWorkOrder = await mongoose
      .model("production_plan_work_order")
      .findById(workOrderId)
      .populate("materialId");

    if (!beforeWorkOrder) {
      console.log(`æœªæ‰¾åˆ°å·¥å•(ID: ${workOrderId})`);
      throw new Error(`æœªæ‰¾åˆ°å·¥å•(ID: ${workOrderId})`);
    }

    // è®°å½•æ›´æ–°å‰çš„å€¼
    const beforeQuantity = beforeWorkOrder[updateField] || 0;
    const beforeStatus = beforeWorkOrder.status;

    // æ‰£å‡æ£€æŸ¥
    if (quantity < 0) {
      if (beforeQuantity + quantity < 0) {
        const requestedDecrease = -quantity;
        quantity = -beforeQuantity;
        console.log(
          `å·¥å•(ID: ${workOrderId})${
            type === "input" ? "æŠ•å…¥" : "äº§å‡º"
          }é‡ä¸è¶³ï¼Œæœ€å¤šæ‰£å‡åˆ°0ï¼ˆå½“å‰é‡ï¼š${beforeQuantity}ï¼Œè¯·æ±‚æ‰£å‡ï¼š${requestedDecrease}ï¼Œå®é™…æ‰£å‡ï¼š${-quantity}ï¼‰`
        );
      }
    }

    // å‡†å¤‡æ›´æ–°æ•°æ®
    const updateData = {
      $inc: { [updateField]: quantity },
      $set: {
        updateTime: new Date(),
      },
    };

    if (!beforeWorkOrder.createBy) {
      updateData.$set.createBy = beforeWorkOrder.updateBy;
    }

    // è®¡ç®—è¿›åº¦å’ŒçŠ¶æ€ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
    if (type === "output") {
      const newOutputQuantity = (beforeWorkOrder.outputQuantity || 0) + quantity;
      const planProductionQuantity = beforeWorkOrder.planProductionQuantity || 0;
      const scrapQuantity = beforeWorkOrder.scrapQuantity || 0;
      
      const totalTargetQuantity = planProductionQuantity + scrapQuantity;
      if (totalTargetQuantity > 0) {
        const newProgress = Math.min(100, Math.floor(
          (newOutputQuantity / totalTargetQuantity) * 100
        ));
        updateData.$set.progress = newProgress;
      }

      if (quantity < 0 && beforeWorkOrder.status === "COMPLETED") {
        updateData.$set.status = "PAUSED";
      }
      else if (newOutputQuantity >= planProductionQuantity) {
        updateData.$set.status = "COMPLETED";
        updateData.$set.endTime = new Date();
        updateData.$set.progress = 100;
      }
    }

    // ============= åŸå­æ›´æ–°æ“ä½œ =============
    const startUpdateTime = Date.now();
    const workOrder = await mongoose
      .model("production_plan_work_order")
      .findOneAndUpdate(
        { _id: workOrderId },
        updateData,
        { 
          new: true,
          populate: "materialId"
        }
      );

    if (!workOrder) {
      throw new Error(`æ›´æ–°å·¥å•å¤±è´¥(ID: ${workOrderId})`);
    }

    const updateDuration = Date.now() - startUpdateTime;
    const afterQuantity = workOrder[updateField];

    // ============= è®°å½•æˆåŠŸçš„æ›´æ–°æ—¥å¿— =============
    try {
      await WorkOrderUpdateLog.create({
        requestId,
        workOrderId: workOrder._id,
        workOrderNo: workOrder.workOrderNo || workOrder.workOrderNumber || "",
        type,
        quantity,
        beforeValue: beforeQuantity,
        afterValue: afterQuantity,
        workerId: logContext.workerId,
        jobId: logContext.jobId,
        duration: updateDuration,
        logContext,
        status: 'SUCCESS',
      });
      
      console.log(`ğŸ“ å·²è®°å½•æ›´æ–°æ—¥å¿—: ${requestId}`);
    } catch (logError) {
      // æ—¥å¿—è®°å½•å¤±è´¥ä¸åº”è¯¥å½±å“ä¸»æµç¨‹ï¼Œä½†è¦è®°å½•é”™è¯¯
      console.error(`âš ï¸ è®°å½•æ›´æ–°æ—¥å¿—å¤±è´¥ (ä¸å½±å“ä¸»æµç¨‹):`, logError);
      
      // å¦‚æœæ˜¯é‡å¤é”®é”™è¯¯ï¼Œè¯´æ˜å­˜åœ¨å¹¶å‘é—®é¢˜
      if (logError.code === 11000) {
        console.error(`ğŸš¨ æ£€æµ‹åˆ°å¹¶å‘é‡å¤æ›´æ–°: ${requestId}`);
        // è¿™é‡Œå¯ä»¥è§¦å‘å‘Šè­¦
      }
    }

    // å¤„ç†å…³è”å·¥å•ï¼ˆä¿æŒåŸæœ‰é€»è¾‘ï¼‰
    if (type === "output" && workOrder.status === "COMPLETED" && beforeStatus !== "COMPLETED") {
      console.log(`å·¥å•(ID: ${workOrderId})å·²å®Œæˆ - äº§å‡ºé‡: ${workOrder.outputQuantity}, è®¡åˆ’æ•°é‡: ${workOrder.planProductionQuantity}`);
      await this.completeAllRelatedWorkOrders(workOrder._id);
    }

    console.log(`âœ… å·¥å•${type === "input" ? "æŠ•å…¥" : "äº§å‡º"}æ•°é‡æ›´æ–°æˆåŠŸ:`, {
      workOrderId: workOrder._id,
      workOrderNo: workOrder.workOrderNo,
      beforeQuantity,
      afterQuantity,
      change: quantity,
    });

    return {
      success: true,
      isDuplicate: false,
      workOrder,
      beforeQuantity,
      afterQuantity,
      requestId,
    };
    
  } catch (error) {
    // ============= è®°å½•å¤±è´¥çš„æ—¥å¿— =============
    try {
      const WorkOrderUpdateLog = require('../model/project/workOrderUpdateLog');
      await WorkOrderUpdateLog.create({
        requestId: `${requestId}_FAILED_${Date.now()}`,
        workOrderId,
        type,
        quantity,
        status: 'FAILED',
        errorMessage: error.message,
        workerId: logContext.workerId,
        jobId: logContext.jobId,
        logContext,
      });
    } catch (logError) {
      console.error('è®°å½•å¤±è´¥æ—¥å¿—æ—¶å‡ºé”™:', logError);
    }
    
    console.error(
      `æ›´æ–°å·¥å•${type === "input" ? "æŠ•å…¥" : "äº§å‡º"}æ•°é‡å¤±è´¥:`,
      error
    );
    
    throw error;
  }
}
```

### åœ¨é˜Ÿåˆ—ä¸­ä¼ é€’requestId

```javascript
// queueService.js ä¿®æ”¹
static async addWorkOrderQuantityUpdate(workOrderId, type, quantity = 1, logContext = {}) {
  try {
    console.log(`æ·»åŠ å·¥å•æ›´æ–°ä»»åŠ¡åˆ°é˜Ÿåˆ—: ${workOrderId}, type: ${type}, quantity: ${quantity}`);

    // ============= ç”Ÿæˆå”¯ä¸€çš„è¯·æ±‚ID =============
    const requestId = `${workOrderId}_${type}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    const job = await workOrderQueue.add(
      'update-quantity',
      {
        workOrderId,
        type,
        quantity,
        logContext: {
          ...logContext,
          requestId, // å°†requestIdæ·»åŠ åˆ°logContextä¸­
        },
        timestamp: Date.now(),
        requestId, // åŒæ—¶ä½œä¸ºé¡¶å±‚å­—æ®µ
      },
      {
        jobId: `${requestId}`, // ä½¿ç”¨requestIdä½œä¸ºjobIdï¼Œç¡®ä¿å”¯ä¸€æ€§
        priority: this.getTaskPriority(type),
        delay: 0,
      }
    );

    console.log(`å·¥å•æ›´æ–°ä»»åŠ¡å·²æ·»åŠ åˆ°é˜Ÿåˆ—: JobId=${job.id}, WorkOrderId=${workOrderId}, RequestId=${requestId}`);

    return {
      success: true,
      jobId: job.id,
      requestId, // è¿”å›requestId
      workOrderId: workOrderId,
      type: type,
      quantity: quantity,
      message: 'æ›´æ–°ä»»åŠ¡å·²åŠ å…¥é˜Ÿåˆ—',
      estimatedDelay: await this.getEstimatedDelay(),
      queueLength: (workOrderQueue.getWaiting ? 
        await workOrderQueue.getWaiting() : 
        await workOrderQueue.waiting()).length
    };

  } catch (error) {
    console.error('æ·»åŠ å·¥å•æ›´æ–°ä»»åŠ¡åˆ°é˜Ÿåˆ—å¤±è´¥:', error);
    return {
      success: false,
      error: error.message,
      workOrderId: workOrderId,
      type: type,
      quantity: quantity
    };
  }
}
```

---

## æ”¹è¿›æ–¹æ¡ˆ3: æ•°æ®ä¸€è‡´æ€§ç›‘æ§

### å®šæœŸæ ¡éªŒè„šæœ¬

```javascript
// scripts/verify-workorder-consistency.js

const mongoose = require('mongoose');
require('../db'); // è¿æ¥æ•°æ®åº“

const WorkOrder = require('../model/project/productionPlanWorkOrder');
const WorkOrderUpdateLog = require('../model/project/workOrderUpdateLog');

/**
 * éªŒè¯å·¥å•æ•°æ®ä¸€è‡´æ€§
 */
async function verifyWorkOrderConsistency(options = {}) {
  const {
    workOrderId = null, // æŒ‡å®šå·¥å•IDï¼Œä¸ºnullåˆ™æ£€æŸ¥æ‰€æœ‰
    days = 7, // æ£€æŸ¥æœ€è¿‘Nå¤©çš„æ•°æ®
    autoFix = false, // æ˜¯å¦è‡ªåŠ¨ä¿®å¤ä¸ä¸€è‡´
  } = options;

  console.log('=== å¼€å§‹å·¥å•æ•°æ®ä¸€è‡´æ€§æ ¡éªŒ ===');
  console.log(`æ£€æŸ¥èŒƒå›´: æœ€è¿‘${days}å¤©`);
  console.log(`è‡ªåŠ¨ä¿®å¤: ${autoFix ? 'æ˜¯' : 'å¦'}`);

  try {
    // æ„å»ºæŸ¥è¯¢æ¡ä»¶
    const dateThreshold = new Date();
    dateThreshold.setDate(dateThreshold.getDate() - days);

    const logQuery = {
      processedAt: { $gte: dateThreshold },
      status: 'SUCCESS',
    };

    if (workOrderId) {
      logQuery.workOrderId = workOrderId;
    }

    // è·å–æ‰€æœ‰æˆåŠŸçš„æ›´æ–°æ—¥å¿—
    const logs = await WorkOrderUpdateLog.find(logQuery).sort({ processedAt: 1 });

    console.log(`æ‰¾åˆ° ${logs.length} æ¡æ›´æ–°æ—¥å¿—`);

    // æŒ‰å·¥å•IDåˆ†ç»„
    const logsByWorkOrder = {};
    logs.forEach(log => {
      const id = log.workOrderId.toString();
      if (!logsByWorkOrder[id]) {
        logsByWorkOrder[id] = { input: [], output: [] };
      }
      logsByWorkOrder[id][log.type].push(log);
    });

    const results = {
      total: 0,
      consistent: 0,
      inconsistent: 0,
      details: [],
    };

    // é€ä¸ªå·¥å•è¿›è¡Œæ ¡éªŒ
    for (const [workOrderIdStr, groupedLogs] of Object.entries(logsByWorkOrder)) {
      results.total++;

      // è·å–å½“å‰å·¥å•æ•°æ®
      const workOrder = await WorkOrder.findById(workOrderIdStr);
      
      if (!workOrder) {
        console.warn(`âš ï¸ å·¥å•ä¸å­˜åœ¨: ${workOrderIdStr}`);
        continue;
      }

      // è®¡ç®—æ—¥å¿—ä¸­çš„æŠ•å…¥é‡å’Œäº§å‡ºé‡
      const calculateQuantityFromLogs = (logs) => {
        if (logs.length === 0) return 0;
        
        // ä½¿ç”¨æœ€åä¸€æ¡æ—¥å¿—çš„afterValueä½œä¸ºæœ€ç»ˆå€¼
        // è¿™æ ·å¯ä»¥å¤„ç†æ‰£å‡çš„æƒ…å†µ
        return logs[logs.length - 1].afterValue;
      };

      const expectedInput = calculateQuantityFromLogs(groupedLogs.input);
      const expectedOutput = calculateQuantityFromLogs(groupedLogs.output);

      const actualInput = workOrder.inputQuantity || 0;
      const actualOutput = workOrder.outputQuantity || 0;

      const inputMatch = expectedInput === actualInput;
      const outputMatch = expectedOutput === actualOutput;

      if (inputMatch && outputMatch) {
        results.consistent++;
        console.log(`âœ… å·¥å• ${workOrder.workOrderNo || workOrderIdStr}: æ•°æ®ä¸€è‡´`);
      } else {
        results.inconsistent++;
        
        const detail = {
          workOrderId: workOrderIdStr,
          workOrderNo: workOrder.workOrderNo,
          inputMatch,
          outputMatch,
          input: {
            expected: expectedInput,
            actual: actualInput,
            diff: actualInput - expectedInput,
          },
          output: {
            expected: expectedOutput,
            actual: actualOutput,
            diff: actualOutput - expectedOutput,
          },
          logs: {
            inputCount: groupedLogs.input.length,
            outputCount: groupedLogs.output.length,
          },
        };

        results.details.push(detail);

        console.error(`âŒ å·¥å• ${workOrder.workOrderNo || workOrderIdStr}: æ•°æ®ä¸ä¸€è‡´`);
        console.error(`   æŠ•å…¥é‡ - æœŸæœ›: ${expectedInput}, å®é™…: ${actualInput}, å·®å¼‚: ${detail.input.diff}`);
        console.error(`   äº§å‡ºé‡ - æœŸæœ›: ${expectedOutput}, å®é™…: ${actualOutput}, å·®å¼‚: ${detail.output.diff}`);

        // è‡ªåŠ¨ä¿®å¤ï¼ˆè°¨æ…ä½¿ç”¨ï¼‰
        if (autoFix) {
          console.log(`ğŸ”§ è‡ªåŠ¨ä¿®å¤å·¥å•: ${workOrderIdStr}`);
          
          await WorkOrder.findByIdAndUpdate(workOrderIdStr, {
            $set: {
              inputQuantity: expectedInput,
              outputQuantity: expectedOutput,
              updateTime: new Date(),
            }
          });

          console.log(`âœ… å·²ä¿®å¤å·¥å•æ•°æ®`);
        }
      }
    }

    // è¾“å‡ºç»Ÿè®¡ç»“æœ
    console.log('\n=== æ ¡éªŒç»“æœç»Ÿè®¡ ===');
    console.log(`æ€»å·¥å•æ•°: ${results.total}`);
    console.log(`ä¸€è‡´: ${results.consistent} (${((results.consistent / results.total) * 100).toFixed(2)}%)`);
    console.log(`ä¸ä¸€è‡´: ${results.inconsistent} (${((results.inconsistent / results.total) * 100).toFixed(2)}%)`);

    if (results.inconsistent > 0) {
      console.log('\n=== ä¸ä¸€è‡´è¯¦æƒ… ===');
      results.details.forEach(detail => {
        console.log(`\nå·¥å•: ${detail.workOrderNo || detail.workOrderId}`);
        console.log(`  æŠ•å…¥é‡: æœŸæœ› ${detail.input.expected}, å®é™… ${detail.input.actual}, å·®å¼‚ ${detail.input.diff}`);
        console.log(`  äº§å‡ºé‡: æœŸæœ› ${detail.output.expected}, å®é™… ${detail.output.actual}, å·®å¼‚ ${detail.output.diff}`);
      });
    }

    return results;

  } catch (error) {
    console.error('æ ¡éªŒå¤±è´¥:', error);
    throw error;
  }
}

// å‘½ä»¤è¡Œä½¿ç”¨
if (require.main === module) {
  const workOrderId = process.argv[2] || null;
  const days = parseInt(process.argv[3]) || 7;
  const autoFix = process.argv[4] === 'true';

  verifyWorkOrderConsistency({
    workOrderId,
    days,
    autoFix,
  })
    .then(() => {
      console.log('\næ ¡éªŒå®Œæˆ');
      process.exit(0);
    })
    .catch(error => {
      console.error('æ ¡éªŒå¤±è´¥:', error);
      process.exit(1);
    });
}

module.exports = { verifyWorkOrderConsistency };
```

### å®šæ—¶ä»»åŠ¡é…ç½®

```javascript
// åœ¨app.jsæˆ–å•ç‹¬çš„è°ƒåº¦æ–‡ä»¶ä¸­æ·»åŠ 

const schedule = require('node-schedule');
const { verifyWorkOrderConsistency } = require('./scripts/verify-workorder-consistency');

// æ¯å¤©å‡Œæ™¨3ç‚¹æ‰§è¡Œæ•°æ®ä¸€è‡´æ€§æ ¡éªŒ
schedule.scheduleJob('0 3 * * *', async () => {
  console.log('å¼€å§‹å®šæ—¶å·¥å•æ•°æ®ä¸€è‡´æ€§æ ¡éªŒ');
  
  try {
    const results = await verifyWorkOrderConsistency({
      days: 1, // æ£€æŸ¥æœ€è¿‘1å¤©çš„æ•°æ®
      autoFix: false, // ä¸è‡ªåŠ¨ä¿®å¤ï¼Œåªå‘Šè­¦
    });

    // å¦‚æœå‘ç°ä¸ä¸€è‡´ï¼Œå‘é€å‘Šè­¦
    if (results.inconsistent > 0) {
      // è¿™é‡Œå¯ä»¥é›†æˆé‚®ä»¶ã€é’‰é’‰ã€ä¼ä¸šå¾®ä¿¡ç­‰å‘Šè­¦
      console.error(`ğŸš¨ å‘ç° ${results.inconsistent} ä¸ªå·¥å•æ•°æ®ä¸ä¸€è‡´ï¼Œè¯·åŠæ—¶å¤„ç†ï¼`);
      
      // ç¤ºä¾‹ï¼šå‘é€é’‰é’‰å‘Šè­¦
      // await sendDingTalkAlert({
      //   title: 'å·¥å•æ•°æ®ä¸ä¸€è‡´å‘Šè­¦',
      //   content: `å‘ç° ${results.inconsistent} ä¸ªå·¥å•æ•°æ®ä¸ä¸€è‡´`,
      //   details: results.details,
      // });
    }
  } catch (error) {
    console.error('å®šæ—¶æ ¡éªŒå¤±è´¥:', error);
  }
});
```

---

## éƒ¨ç½²æ­¥éª¤

### 1. æ•°æ®åº“è¿ç§»

```bash
# åˆ›å»ºæ›´æ–°æ—¥å¿—é›†åˆå’Œç´¢å¼•
mongo your_database_name

db.createCollection("work_order_update_logs")

db.work_order_update_logs.createIndex({ "requestId": 1 }, { unique: true })
db.work_order_update_logs.createIndex({ "workOrderId": 1, "processedAt": -1 })
db.work_order_update_logs.createIndex({ "status": 1, "processedAt": -1 })
db.work_order_update_logs.createIndex({ "processedAt": 1 }, { expireAfterSeconds: 2592000 })
```

### 2. ä»£ç éƒ¨ç½²

```bash
# 1. å¤‡ä»½å½“å‰ä»£ç 
cp dcMes_server/services/queueService.js dcMes_server/services/queueService.js.backup
cp dcMes_server/services/materialProcessFlowService.js dcMes_server/services/materialProcessFlowService.js.backup

# 2. æ›´æ–°ä»£ç ï¼ˆåº”ç”¨ä¸Šè¿°æ”¹è¿›ï¼‰

# 3. é‡å¯æœåŠ¡
pm2 restart all
```

### 3. ç›‘æ§éªŒè¯

```bash
# è§‚å¯Ÿæ—¥å¿—ï¼Œç¡®è®¤æ”¹è¿›ç”Ÿæ•ˆ
pm2 logs | grep "é”æ‰©å±•"

# è¿è¡Œä¸€è‡´æ€§æ ¡éªŒ
node dcMes_server/scripts/verify-workorder-consistency.js null 7 false
```

---

## ç›‘æ§æŒ‡æ ‡

### åœ¨ä»£ç ä¸­æ·»åŠ ç›‘æ§æŒ‡æ ‡

```javascript
// queueService.js æ·»åŠ ç›‘æ§ç»Ÿè®¡

class QueueMetrics {
  constructor() {
    this.metrics = {
      // é”ç›¸å…³æŒ‡æ ‡
      lockExtensionAttempts: 0,
      lockExtensionSuccesses: 0,
      lockExtensionFailures: 0,
      lockInvalidations: 0,
      
      // ä»»åŠ¡ç›¸å…³æŒ‡æ ‡
      tasksProcessed: 0,
      tasksSucceeded: 0,
      tasksFailed: 0,
      
      // å¹‚ç­‰æ€§æŒ‡æ ‡
      duplicateRequests: 0,
      
      // æ€§èƒ½æŒ‡æ ‡
      totalDuration: 0,
      maxDuration: 0,
      minDuration: Infinity,
    };
  }

  recordLockExtension(success) {
    this.metrics.lockExtensionAttempts++;
    if (success) {
      this.metrics.lockExtensionSuccesses++;
    } else {
      this.metrics.lockExtensionFailures++;
    }
  }

  recordLockInvalidation() {
    this.metrics.lockInvalidations++;
  }

  recordTask(success, duration, isDuplicate = false) {
    this.metrics.tasksProcessed++;
    if (success) {
      this.metrics.tasksSucceeded++;
    } else {
      this.metrics.tasksFailed++;
    }
    
    if (isDuplicate) {
      this.metrics.duplicateRequests++;
    }

    this.metrics.totalDuration += duration;
    this.metrics.maxDuration = Math.max(this.metrics.maxDuration, duration);
    this.metrics.minDuration = Math.min(this.metrics.minDuration, duration);
  }

  getStats() {
    const avgDuration = this.metrics.tasksProcessed > 0
      ? this.metrics.totalDuration / this.metrics.tasksProcessed
      : 0;

    return {
      ...this.metrics,
      avgDuration,
      lockExtensionSuccessRate: this.metrics.lockExtensionAttempts > 0
        ? (this.metrics.lockExtensionSuccesses / this.metrics.lockExtensionAttempts * 100).toFixed(2) + '%'
        : 'N/A',
      taskSuccessRate: this.metrics.tasksProcessed > 0
        ? (this.metrics.tasksSucceeded / this.metrics.tasksProcessed * 100).toFixed(2) + '%'
        : 'N/A',
    };
  }

  reset() {
    this.metrics = {
      lockExtensionAttempts: 0,
      lockExtensionSuccesses: 0,
      lockExtensionFailures: 0,
      lockInvalidations: 0,
      tasksProcessed: 0,
      tasksSucceeded: 0,
      tasksFailed: 0,
      duplicateRequests: 0,
      totalDuration: 0,
      maxDuration: 0,
      minDuration: Infinity,
    };
  }
}

const queueMetrics = new QueueMetrics();

// æ¯åˆ†é’Ÿè¾“å‡ºä¸€æ¬¡ç»Ÿè®¡
setInterval(() => {
  const stats = queueMetrics.getStats();
  console.log('=== é˜Ÿåˆ—æœåŠ¡ç»Ÿè®¡ (æœ€è¿‘1åˆ†é’Ÿ) ===');
  console.log(JSON.stringify(stats, null, 2));
  
  // æ£€æµ‹å¼‚å¸¸æƒ…å†µå¹¶å‘Šè­¦
  if (stats.lockInvalidations > 0) {
    console.error(`ğŸš¨ æ£€æµ‹åˆ° ${stats.lockInvalidations} æ¬¡é”å¤±æ•ˆäº‹ä»¶ï¼`);
  }
  
  if (stats.duplicateRequests > 0) {
    console.warn(`âš ï¸ æ£€æµ‹åˆ° ${stats.duplicateRequests} æ¬¡é‡å¤è¯·æ±‚ï¼`);
  }
  
  // é‡ç½®è®¡æ•°å™¨ï¼ˆæˆ–è€…ä¿ç•™ç´¯è®¡å€¼ï¼Œæ ¹æ®éœ€æ±‚å†³å®šï¼‰
  // queueMetrics.reset();
}, 60000);
```

---

## æµ‹è¯•éªŒè¯

### å¹¶å‘æµ‹è¯•è„šæœ¬

```javascript
// test/workorder-concurrent-test.js

const axios = require('axios');

async function testConcurrentUpdates() {
  const workOrderId = 'ä½ çš„æµ‹è¯•å·¥å•ID';
  const concurrentRequests = 10;

  console.log(`å‘èµ· ${concurrentRequests} ä¸ªå¹¶å‘è¯·æ±‚...`);

  const requests = [];
  for (let i = 0; i < concurrentRequests; i++) {
    requests.push(
      axios.post('http://localhost:3000/api/v1/material-process-flow/update-workorder', {
        workOrderId,
        type: 'input',
        quantity: 1,
        logContext: {
          operatorId: 'TEST',
          source: 'CONCURRENT_TEST',
        },
      })
    );
  }

  const results = await Promise.allSettled(requests);

  console.log('\næµ‹è¯•ç»“æœ:');
  console.log(`æˆåŠŸ: ${results.filter(r => r.status === 'fulfilled').length}`);
  console.log(`å¤±è´¥: ${results.filter(r => r.status === 'rejected').length}`);

  // æŸ¥è¯¢æœ€ç»ˆçš„æŠ•å…¥é‡
  const workOrder = await axios.get(`http://localhost:3000/api/v1/workorder/${workOrderId}`);
  console.log(`\næœ€ç»ˆæŠ•å…¥é‡: ${workOrder.data.inputQuantity}`);
  console.log(`é¢„æœŸæŠ•å…¥é‡: ${concurrentRequests}`);
  console.log(`æ˜¯å¦ä¸€è‡´: ${workOrder.data.inputQuantity === concurrentRequests ? 'âœ…' : 'âŒ'}`);
}

testConcurrentUpdates().catch(console.error);
```

---

## æ€»ç»“

è¿™å¥—æ”¹è¿›æ–¹æ¡ˆå®ç°äº†ï¼š

1. âœ… **é”ç»­æœŸç›‘æ§**: å®æ—¶æ£€æµ‹é”çš„æœ‰æ•ˆæ€§ï¼Œå¤±è´¥æ—¶ç«‹å³ç»ˆæ­¢ä»»åŠ¡
2. âœ… **å¹‚ç­‰æ€§ä¿æŠ¤**: åŸºäºrequestIdé˜²æ­¢é‡å¤æ‰§è¡Œ
3. âœ… **æ•°æ®ä¸€è‡´æ€§æ ¡éªŒ**: å®šæœŸéªŒè¯æ•°æ®å®Œæ•´æ€§
4. âœ… **ç›‘æ§å‘Šè­¦**: å®Œæ•´çš„æŒ‡æ ‡ç»Ÿè®¡å’Œå¼‚å¸¸å‘Šè­¦
5. âœ… **é™çº§å¤„ç†**: åœ¨å¼‚å¸¸æƒ…å†µä¸‹çš„å®‰å…¨å¤„ç†æœºåˆ¶

**é¢„æœŸæ•ˆæœ**:
- å®Œå…¨è§£å†³ç½‘ç»œå»¶è¿Ÿå¯¼è‡´çš„é‡å¤æ‰£å‡é—®é¢˜
- æä¾›æ•°æ®ä¸ä¸€è‡´çš„æ£€æµ‹å’Œä¿®å¤èƒ½åŠ›
- å¢å¼ºç³»ç»Ÿçš„å¯è§‚æµ‹æ€§å’Œå¯ç»´æŠ¤æ€§

**å»ºè®®å®æ–½é¡ºåº**:
1. ç¬¬ä¸€å‘¨: å®æ–½æ–¹æ¡ˆ1ï¼ˆé”ç»­æœŸç›‘æ§ï¼‰ - æœ€å…³é”®
2. ç¬¬äºŒå‘¨: å®æ–½æ–¹æ¡ˆ2ï¼ˆå¹‚ç­‰æ€§æœºåˆ¶ï¼‰ - æ¬¡å…³é”®
3. ç¬¬ä¸‰å‘¨: å®æ–½æ–¹æ¡ˆ3ï¼ˆæ•°æ®ä¸€è‡´æ€§ç›‘æ§ï¼‰ - è¾…åŠ©å·¥å…·






















